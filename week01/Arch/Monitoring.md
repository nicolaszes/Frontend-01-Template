# Monitoring 性能监控

## 前端

帮助用户定位页面性能瓶颈，复现用户端的偶发问题。

####主要功能：

* 日志采集
* 日志上报
* 数据分析
* 平台展示
* 异常报警

####主要问题：

* 平台可以监控哪些数据
* 会不会影响业务性能

####监控指标

* 访问速度
* 服务调用成功率
* 页面运行稳定性

####页面是否正常响应，阿里云为例（12个关键性能指标）

1. DNS 解析耗时

2. TCP 连接耗时

3. SSL 安全连接耗时

4. 网络请求耗时

5. DOM 解析耗时

6. 资源加载耗时

7. 首包时间

8. **白屏时间**

   指浏览器开始显示内容的时间。但是在传统的采集方式里，是在HTML的head标签结尾里记录时间戳，来计算白屏时间。

9. **首屏时间**

   首屏时间（FirstScreen Time），是从网页应用的角度定义的指标，在Navigation Timing或者浏览器实现中并没有相关指标值。首屏时间，是指用户看到第一屏，即整个网页顶部大小为当前窗口的区域，显示完整的时间。常用的方法有，页面标签标记法、图像相似度比较法和首屏高度内图片加载法；

   1. 页面标签标记法，在HTML文档中对应首屏内容的标签结束位置，使用内联的JavaScript代码记录当前时间戳，比较局限；
   2. 图像相似度比较法，通过比较连续截屏图像的像素点变化趋势确定首屏时间，最为科学和直观的方式，但是比较消耗本地设备的运行资源；
   3. 首屏高度内图片加载法，通过寻找首屏区域内的所有图片，计算它们加载完的时间去得到首屏时间，这样比较符合网页的实际体验并且比较节省设备运行资源；

10. TTI（Time To Interactive, 后文使用TTI缩写）性能

11. DOM ready 时间

12. 页面完全加载时间



![img](https://images2015.cnblogs.com/blog/831429/201608/831429-20160822134136245-1553126506.png)

在浏览器交互阶段（Processing和onLoad时间段）浏览器接收服务器返回的基础页数据后，浏览器需要对HTML这个单纯的文本内容进行解析，从文本中构建出一个内部数据结构，叫做DOM树（DOM tree），用于组织将要绘制在屏幕上的内容。

从HTML也能得到外联或内联的CSS脚本和JavaScript脚本，当然还有媒体文件，比如图片、视频、声音，这些都需要再次发起网络请求下载。CSS文本内容中的规则同样会被构建成一个内部数据结构，叫做CSS树（CSS tree），来决定DOM树的节点在屏幕上的布局、颜色、状态效果。

JavaScript脚本被触发执行后，除了计算业务，往往还需要操作DOM树，就是所谓的DOM API。



## APP

## Node

### 指标

* CPU
* 内存
* 磁盘
* I/O
* 网络



#### CPU

CPU负载和CPU利用率：评估当前CPU的繁忙程度的量化指标

##### CPU负载

某个时间段内，占用以及等待 CPU 的进程总数，loadavg

#####CPU 利用率

1 - (idle time / CPU 总时间)

##### 量化 CPU 指标

1min, 5min, 15min

1min 很难得到较为均衡的指标，因为 1min 太短，但峰值过高？？？

5min / 15min都保持高负荷，对于整个系统来说是危险的。

```js
const os = require('os')
const length = os.cpus.length()
os.loadavg().map(load => load / length) // 单核 CPU 平均负载
```

CPU 利用率不太好作为直接评判标准的数值。

由于进程阻塞 CPU的原因各不相同。对于 CPU 密集型任务来说，CPU利用率可以很好的表示当前 CPU 的工作状态。但对于 I/O 密集型来说，可能是任务被挂起了，去进行其他操作了。

SSR 来说，渲染可以理解为 CPU密集型任务，所以这个指标在一定程度上可以体现当前业务环境的 CPU性能。

### 内存指标

#### rss

node进程占用的内存总量

#### heapTotal

堆内存的总量

#### heapUsed

实际堆内存的使用量

#### external

外部程序的内存使用量



node的分代 GC算法会在一定程度上浪费部分内存资源，所以当 heapUsed 达到 heapTotal一半的时候，就可以强制触发 GC操作 global.gc()

### QPS



### 测试